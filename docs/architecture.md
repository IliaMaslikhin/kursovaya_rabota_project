# Архитектура OilErp (максимально просто)

## Что это за проект
OilErp — учебная система про:
- оборудование (активы);
- замеры толщины (коррозия);
- расчет скорости коррозии (**CR**) и уровня риска по политике.

Главная идея: **заводы пишут замеры у себя**, а в **central** уходит «короткая выжимка», и central сам пересчитывает аналитику.

## Состав системы (что где живет)
### Базы PostgreSQL
- `central` — главная база:
  - хранит общий справочник оборудования (`assets_global`);
  - хранит политики риска (`risk_policies`);
  - хранит журнал «батчей» замеров (`measurement_batches`);
  - хранит витрину аналитики (`analytics_cr`).
- `anpz`, `krnpz` — базы заводов:
  - хранят локальные замеры (`measurements`) и точки (`measurement_points`);
  - отправляют батчи в central через **FDW**.

### .NET проекты
- `OilErp.Ui` — основной интерфейс (то, чем вы пользуетесь).
- `OilErp.Core` — контракты, DTO и сервисы‑обертки над SQL.
- `OilErp.Infrastructure` — реальная работа с PostgreSQL (Npgsql), bootstrap и проверка схемы.
- `OilErp.Tests.Runner` — смоук‑проверки (UI запускает их перед стартом).

## Слова, которые будут встречаться
- **Ingest (ингест)** — «принять данные и провести по цепочке до результата». У нас ingest = путь *от замера на заводе → до записи в central → до обновления `analytics_cr`*.
- **FDW** — “foreign data wrapper”: на заводе есть «внешняя таблица», которая на самом деле лежит в central.
- **Триггер** — автоматическая логика, которая срабатывает при вставке строки.

## Как работает ingest (самое важное)
Опишу прямо шагами, без красивостей.

### Шаг 1. На заводе кто‑то добавляет замер
Источник может быть UI или любая другая программа. Суть: вызывается заводская функция:
- `public.sp_insert_measurement_batch(p_asset_code, p_points, p_source_plant)`

Она делает простые вещи:
- проверяет, что `asset_code` не пустой;
- проверяет, что `p_points` — это JSON‑массив точек;
- чистит и нормализует точки (label/ts/thickness/note), выбрасывает некорректные;
- сортирует точки по времени;
- вызывает процедуру `public.sp_insert_measurement_batch_prc(...)`.

### Шаг 2. Завод записывает замер у себя
Процедура `public.sp_insert_measurement_batch_prc` на заводе:
- создает/находит актив в `assets_local`;
- создает/находит точки в `measurement_points`;
- вставляет строки в `measurements`;
- следит за правилами (время должно идти вперед, толщина не должна расти).

### Шаг 3. Завод отправляет «батч» в central через FDW
После локальной записи завод собирает **батч** — это не все точки, а только:
- `prev_*` — предыдущий замер;
- `last_*` — последний замер.

И вставляет одну строку в `central_ft.measurement_batches`.
`central_ft` — это FDW‑схема на заводе, а сама таблица физически лежит в `central.public.measurement_batches`.

Почему так: central не обязан знать все сырые точки, ему достаточно prev/last для расчета CR.

### Шаг 4. Central сам обновляет аналитику триггером
В `central.public.measurement_batches` стоит триггер `trg_measurement_batches_bi`.
Он срабатывает на каждую вставку батча и делает два действия:
1) гарантирует наличие актива в `assets_global` (иначе внешние ключи мешали бы);
2) делает upsert в `analytics_cr` и считает CR через `fn_calc_cr`.

Результат: **батч попал в central → `analytics_cr` обновилась автоматически**.

## Где UI берет данные
Упрощенно:
- список оборудования — из `assets_global` (и частично из батчей, если актив пришел только с завода);
- аналитика CR — из `analytics_cr`;
- риск — считается по порогам `risk_policies` (UI может показать риск по выбранной политике).

## «Кто за что отвечает» в коде (коротко)
- Подключение/проверка БД: `KernelGateway` → `DatabaseBootstrapper` → `DatabaseInventoryInspector`.
- Доступ к SQL из кода: `IStoragePort` (контракт) → `StorageAdapter` (реализация на Npgsql).
- Запись замера на завод: `PlantMeasurementsTabViewModel` → `SpInsertMeasurementBatchService` → SQL на заводе → FDW → триггер в central.

## Важные практические детали (почему иногда “не работает”)
- Внешняя таблица `central_ft.measurement_batches` **не должна** включать `id/created_at`, иначе `postgres_fdw` может отправить `NULL` и insert сломается.
- В заводской функции разбор JSON должен быть через `x.value->>'field'` (иначе бывают ошибки типа `record ->> unknown`).
- В UI “KRNPZ” приводится к “KNPZ” (это нормально, так сделана нормализация названия).
