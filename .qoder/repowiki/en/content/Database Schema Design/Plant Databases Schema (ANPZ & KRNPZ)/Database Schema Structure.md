# Database Schema Structure

<cite>
**Referenced Files in This Document**   
- [01_tables.sql](file://sql/anpz/01_tables.sql)
- [01_tables.sql](file://sql/krnpz/01_tables.sql)
- [Asset.cs](file://src/OilErp.Domain/Entities/Asset.cs)
- [MeasurementPoint.cs](file://src/OilErp.Domain/Entities/MeasurementPoint.cs)
- [Reading.cs](file://src/OilErp.Domain/Entities/Reading.cs)
</cite>

## Table of Contents
1. [Introduction](#introduction)
2. [Core Tables Overview](#core-tables-overview)
3. [Entity-Relationship Diagram](#entity-relationship-diagram)
4. [Detailed Table Definitions](#detailed-table-definitions)
5. [Data Integrity Constraints](#data-integrity-constraints)
6. [Indexing Strategy and Query Performance](#indexing-strategy-and-query-performance)
7. [Local Data Model and Synchronization Context](#local-data-model-and-synchronization-context)
8. [Common Query Patterns](#common-query-patterns)
9. [Batch Processing Support](#batch-processing-support)
10. [Conclusion](#conclusion)

## Introduction
This document provides comprehensive documentation for the plant database schema structure used in both ANPZ and KRNPZ databases. The schema is designed to store local measurement data from oil industry assets before synchronization with a central system. It consists of four core tables: `assets_local`, `measurement_points`, `measurements`, and `local_events`. These tables form a hierarchical data model that captures asset metadata, measurement locations, actual readings, and system events. The schema emphasizes data integrity through primary keys, foreign key constraints, unique indexes, and check constraints, while supporting efficient querying and batch processing workflows.

**Section sources**
- [01_tables.sql](file://sql/anpz/01_tables.sql#L1-L38)
- [01_tables.sql](file://sql/krnpz/01_tables.sql#L1-L38)

## Core Tables Overview
The database schema consists of four primary tables that form a normalized structure for storing asset measurement data. The `assets_local` table serves as the root entity, containing metadata about physical assets in the oil pipeline system. Each asset can have multiple `measurement_points`, which represent specific locations where readings are taken. The `measurements` table stores individual reading values with timestamps, while `local_events` captures system-level events for auditing and synchronization purposes. This hierarchical structure ensures data consistency and supports complex queries for analytics and reporting.

**Section sources**
- [01_tables.sql](file://sql/anpz/01_tables.sql#L1-L38)
- [01_tables.sql](file://sql/krnpz/01_tables.sql#L1-L38)

## Entity-Relationship Diagram
```mermaid
erDiagram
assets_local {
bigint id PK
text asset_code NOT NULL
text location
text status
timestamptz created_at DEFAULT now()
}
measurement_points {
bigint id PK
bigint asset_id FK NOT NULL
text label NOT NULL
}
measurements {
bigint id PK
bigint point_id FK NOT NULL
timestamptz ts NOT NULL
numeric thickness(10,3) NOT NULL
text note
}
local_events {
bigint id PK
text event_type
jsonb payload_json
timestamptz created_at DEFAULT now()
}
assets_local ||--o{ measurement_points : "has"
measurement_points ||--o{ measurements : "has"
```

**Diagram sources**
- [01_tables.sql](file://sql/anpz/01_tables.sql#L5-L35)
- [01_tables.sql](file://sql/krnpz/01_tables.sql#L5-L35)

## Detailed Table Definitions

### assets_local Table
The `assets_local` table stores metadata about physical assets in the oil pipeline system. Each asset is uniquely identified by a `BIGINT` primary key generated by default as an identity column. The `asset_code` column serves as a business identifier and is indexed for fast lookups. The `location` and `status` columns store descriptive information about the asset's position and operational state. The `created_at` timestamp is automatically set to the current time when a record is inserted.

**Section sources**
- [01_tables.sql](file://sql/anpz/01_tables.sql#L5-L9)
- [01_tables.sql](file://sql/krnpz/01_tables.sql#L5-L9)
- [Asset.cs](file://src/OilErp.Domain/Entities/Asset.cs#L5-L71)

### measurement_points Table
The `measurement_points` table defines specific locations on assets where measurements are taken. Each point is associated with an asset through the `asset_id` foreign key, which enforces referential integrity with cascade delete behavior. The `label` column provides a human-readable name for the measurement point. A unique constraint (`uq_points_asset_label`) ensures that each combination of `asset_id` and `label` is unique, preventing duplicate points on the same asset.

**Section sources**
- [01_tables.sql](file://sql/anpz/01_tables.sql#L11-L15)
- [01_tables.sql](file://sql/krnpz/01_tables.sql#L11-L15)
- [MeasurementPoint.cs](file://src/OilErp.Domain/Entities/MeasurementPoint.cs#L5-L82)

### measurements Table
The `measurements` table stores individual reading values taken at measurement points. Each measurement is linked to a point via the `point_id` foreign key with cascade delete. The `ts` column records the exact time when the measurement was taken, while the `thickness` column stores the numeric value with precision of 10 digits and 3 decimal places. A check constraint ensures that thickness values are always positive. The optional `note` column allows operators to add contextual information about the measurement.

**Section sources**
- [01_tables.sql](file://sql/anpz/01_tables.sql#L17-L23)
- [01_tables.sql](file://sql/krnpz/01_tables.sql#L17-L23)
- [Reading.cs](file://src/OilErp.Domain/Entities/Reading.cs#L5-L81)

### local_events Table
The `local_events` table captures system-level events for auditing and synchronization purposes. Each event has a unique `id` and an optional `event_type` to categorize the event. The `payload_json` column stores event data in JSONB format, allowing flexible schema for different event types. The `created_at` timestamp is automatically set to the current time when an event is recorded. This table serves as a message queue for changes that need to be synchronized with the central database.

**Section sources**
- [01_tables.sql](file://sql/anpz/01_tables.sql#L25-L30)
- [01_tables.sql](file://sql/krnpz/01_tables.sql#L25-L30)

## Data Integrity Constraints

### Primary Keys
All tables use `BIGINT GENERATED BY DEFAULT AS IDENTITY` for their primary keys, providing auto-incrementing unique identifiers. This approach ensures that each record has a unique ID without requiring application-level sequence management. The identity generation is handled by the database, making it reliable and efficient for high-volume data insertion.

### Foreign Key Constraints
The schema enforces referential integrity through foreign key constraints:
- `measurement_points.asset_id` references `assets_local.id` with `ON DELETE CASCADE`
- `measurements.point_id` references `measurement_points.id` with `ON DELETE CASCADE`

These constraints ensure that child records are automatically deleted when their parent records are removed, maintaining data consistency and preventing orphaned records.

### Unique Indexes
The `uq_points_asset_label` unique constraint on `measurement_points(asset_id, label)` prevents duplicate measurement points on the same asset. This ensures that each point has a unique label within the context of its parent asset, avoiding confusion and data duplication.

### Check Constraints
The `thickness > 0` check constraint on the `measurements` table ensures that all thickness values are positive, reflecting the physical reality that wall thickness cannot be zero or negative. This constraint prevents invalid data from being inserted and maintains data quality.

**Section sources**
- [01_tables.sql](file://sql/anpz/01_tables.sql#L5-L35)
- [01_tables.sql](file://sql/krnpz/01_tables.sql#L5-L35)

## Indexing Strategy and Query Performance
The schema includes several indexes to optimize query performance:
- `ix_assets_local_code` on `assets_local(asset_code)` enables fast lookups by asset code
- `ix_assets_local_created_at` on `assets_local(created_at)` supports time-based queries for asset creation
- `ix_measurements_point_ts` on `measurements(point_id, ts)` optimizes retrieval of measurements by point and time range
- `ix_local_events_created_at` on `local_events(created_at)` facilitates chronological processing of events

The composite index on `measurements(point_id, ts)` is particularly important for time-series queries, allowing efficient retrieval of measurements within specific time ranges for a given point. These indexes support the most common query patterns while minimizing overhead on write operations.

**Section sources**
- [01_tables.sql](file://sql/anpz/01_tables.sql#L10-L11)
- [01_tables.sql](file://sql/anpz/01_tables.sql#L24)
- [01_tables.sql](file://sql/anpz/01_tables.sql#L31)
- [01_tables.sql](file://sql/krnpz/01_tables.sql#L10-L11)
- [01_tables.sql](file://sql/krnpz/01_tables.sql#L24)
- [01_tables.sql](file://sql/krnpz/01_tables.sql#L31)

## Local Data Model and Synchronization Context
The schema is designed for local data storage at plant sites (ANPZ and KRNPZ) before synchronization with a central database. The "local" designation in table names (`assets_local`, `local_events`) emphasizes this temporary, site-specific nature of the data. This architecture supports offline operation and reduces network dependency, allowing measurement data to be collected even when connectivity to the central system is unavailable. The `local_events` table plays a crucial role in the synchronization process by logging changes that need to be propagated to the central database.

**Section sources**
- [01_tables.sql](file://sql/anpz/01_tables.sql#L1-L38)
- [01_tables.sql](file://sql/krnpz/01_tables.sql#L1-L38)

## Common Query Patterns

### Retrieve All Measurements for an Asset
```sql
SELECT m.ts, m.thickness, m.note, mp.label
FROM measurements m
JOIN measurement_points mp ON m.point_id = mp.id
JOIN assets_local a ON mp.asset_id = a.id
WHERE a.asset_code = 'ASSET-001'
ORDER BY m.ts DESC;
```

### Get Latest Measurement for Each Point on an Asset
```sql
SELECT DISTINCT ON (mp.id) mp.label, m.ts, m.thickness, m.note
FROM measurements m
JOIN measurement_points mp ON m.point_id = mp.id
JOIN assets_local a ON mp.asset_id = a.id
WHERE a.asset_code = 'ASSET-001'
ORDER BY mp.id, m.ts DESC;
```

### Find Measurements Within a Time Range
```sql
SELECT a.asset_code, mp.label, m.thickness, m.ts
FROM measurements m
JOIN measurement_points mp ON m.point_id = mp.id
JOIN assets_local a ON mp.asset_id = a.id
WHERE m.ts >= '2024-01-01' AND m.ts < '2024-02-01'
ORDER BY m.ts;
```

**Section sources**
- [01_tables.sql](file://sql/anpz/01_tables.sql#L5-L35)
- [01_tables.sql](file://sql/krnpz/01_tables.sql#L5-L35)

## Batch Processing Support
The schema supports batch processing workflows through the `local_events` table and the `sp_insert_measurement_batch` stored procedure (defined in `04_function_sp_insert_measurement_batch.sql`). Measurement batches can be inserted efficiently using bulk operations, with each batch recorded as an event for audit and synchronization purposes. The indexing strategy and foreign key constraints ensure data integrity during batch operations, while the cascade delete behavior simplifies cleanup of related records. This design enables high-throughput data ingestion from field devices while maintaining data consistency.

**Section sources**
- [01_tables.sql](file://sql/anpz/01_tables.sql#L25-L30)
- [01_tables.sql](file://sql/krnpz/01_tables.sql#L25-L30)

## Conclusion
The database schema for ANPZ and KRNPZ plant databases provides a robust foundation for storing and managing asset measurement data. Its normalized structure with strong data integrity constraints ensures data quality and consistency, while the indexing strategy supports efficient querying for analytics and reporting. The local nature of the schema enables offline operation and batch processing, making it well-suited for industrial environments with intermittent connectivity. The design patterns used in this schema, including auto-incrementing IDs, cascade deletes, and JSONB for flexible event data, reflect modern database best practices for industrial IoT applications.